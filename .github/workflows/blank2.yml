# .github/workflows/build-a133p.yml
name: Build sunxi-btlpm for A133P

on: [workflow_dispatch, push]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup environment
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          gcc-aarch64-linux-gnu \
          git build-essential \
          libssl-dev bc flex bison \
          wget cpio

    - name: Download kernel sources
      run: |
        # Option 1: Linux sunxi mainline
        git clone https://github.com/linux-sunxi/linux-sunxi.git -b sunxi-5.19 linux-sunxi
        
        # Option 2: Armbian kernel
        git clone https://github.com/armbian/linux.git -b orange-pi-5.19 armbian-kernel
        
        # Option 3: Mainline kernel
        wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.19.17.tar.xz
        tar -xf linux-5.19.17.tar.xz

    - name: Configure kernel (sunxi)
      run: |
        cd linux-sunxi
        export ARCH=arm64
        export CROSS_COMPILE=aarch64-linux-gnu-
        make defconfig
        make menuconfig <<< EOF
        EOF

    - name: Create sunxi-btlpm module
      run: |
        mkdir -p sunxi-btlpm
        cat > sunxi-btlpm/sunxi-btlpm.c << 'EOF'
        #include <linux/module.h>
        #include <linux/kernel.h>
        #include <linux/init.h>
        #include <linux/gpio.h>
        #include <linux/of_gpio.h>
        #include <linux/delay.h>
        #include <linux/platform_device.h>
        #include <linux/regulator/consumer.h>

        struct sunxi_bt_data {
            int power_gpio;
            int reset_gpio;
            struct regulator *vcc_io;
            struct regulator *vcc_bt;
        };

        static struct sunxi_bt_data *bt_data;

        static int sunxi_bt_probe(struct platform_device *pdev)
        {
            struct device *dev = &pdev->dev;
            struct device_node *np = dev->of_node;
            int ret;

            bt_data = devm_kzalloc(dev, sizeof(*bt_data), GFP_KERNEL);
            if (!bt_data)
                return -ENOMEM;

            // Get power GPIO
            bt_data->power_gpio = of_get_named_gpio(np, "bt_power", 0);
            if (gpio_is_valid(bt_data->power_gpio)) {
                ret = devm_gpio_request(dev, bt_data->power_gpio, "bt_power");
                if (!ret) {
                    gpio_direction_output(bt_data->power_gpio, 1);
                    msleep(100);
                    dev_info(dev, "BT power GPIO %d enabled\n", bt_data->power_gpio);
                }
            }

            // Get reset GPIO
            bt_data->reset_gpio = of_get_named_gpio(np, "bt_reset", 0);
            if (gpio_is_valid(bt_data->reset_gpio)) {
                ret = devm_gpio_request(dev, bt_data->reset_gpio, "bt_reset");
                if (!ret) {
                    gpio_direction_output(bt_data->reset_gpio, 1);
                    msleep(50);
                    dev_info(dev, "BT reset GPIO %d enabled\n", bt_data->reset_gpio);
                }
            }

            // Get regulators
            bt_data->vcc_io = devm_regulator_get(dev, "vcc-io");
            if (!IS_ERR(bt_data->vcc_io)) {
                regulator_set_voltage(bt_data->vcc_io, 1800000, 1800000);
                ret = regulator_enable(bt_data->vcc_io);
                if (ret)
                    dev_warn(dev, "Failed to enable VCC-IO regulator\n");
            }

            bt_data->vcc_bt = devm_regulator_get(dev, "vcc-bt");
            if (!IS_ERR(bt_data->vcc_bt)) {
                regulator_set_voltage(bt_data->vcc_bt, 3300000, 3300000);
                ret = regulator_enable(bt_data->vcc_bt);
                if (ret)
                    dev_warn(dev, "Failed to enable VCC-BT regulator\n");
            }

            dev_info(dev, "Allwinner A133P XR829 Bluetooth PM loaded\n");
            return 0;
        }

        static int sunxi_bt_remove(struct platform_device *pdev)
        {
            if (bt_data) {
                if (gpio_is_valid(bt_data->power_gpio))
                    gpio_set_value(bt_data->power_gpio, 0);
                if (gpio_is_valid(bt_data->reset_gpio))
                    gpio_set_value(bt_data->reset_gpio, 0);
                    
                if (!IS_ERR(bt_data->vcc_io))
                    regulator_disable(bt_data->vcc_io);
                if (!IS_ERR(bt_data->vcc_bt))
                    regulator_disable(bt_data->vcc_bt);
            }
            return 0;
        }

        static const struct of_device_id sunxi_bt_match[] = {
            { .compatible = "allwinner,sunxi-btlpm" },
            { .compatible = "allwinner,xr829-bt" },
            { .compatible = "allwinner,sun50i-a133p-bt" },
            { }
        };
        MODULE_DEVICE_TABLE(of, sunxi_bt_match);

        static struct platform_driver sunxi_bt_driver = {
            .probe = sunxi_bt_probe,
            .remove = sunxi_bt_remove,
            .driver = {
                .name = "sunxi-btlpm",
                .of_match_table = sunxi_bt_match,
            },
        };

        module_platform_driver(sunxi_bt_driver);

        MODULE_LICENSE("GPL");
        MODULE_AUTHOR("GitHub Actions");
        MODULE_DESCRIPTION("Bluetooth power management for Allwinner A133P XR829");
        MODULE_VERSION("1.0");
        EOF

    - name: Create Makefile
      run: |
        cat > sunxi-btlpm/Makefile << 'EOF'
        obj-m += sunxi-btlpm.o

        KERNEL_SRC ?= \$(PWD)/linux-sunxi
        ARCH ?= arm64
        CROSS_COMPILE ?= aarch64-linux-gnu-

        all:
        	\$(MAKE) -C \$(KERNEL_SRC) M=\$(PWD) modules

        clean:
        	\$(MAKE) -C \$(KERNEL_SRC) M=\$(PWD) clean

        help:
        	\$(MAKE) -C \$(KERNEL_SRC) M=\$(PWD) help
        EOF

    - name: Build the module
      run: |
        cd sunxi-btlpm
        make KERNEL_SRC=$(pwd)/../linux-sunxi ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-

    - name: Check module info
      run: |
        cd sunxi-btlpm
        file sunxi-btlpm.ko
        aarch64-linux-gnu-objdump -h sunxi-btlpm.ko | head -20

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: sunxi-btlpm-module
        path: |
          sunxi-btlpm/sunxi-btlpm.ko
          sunxi-btlpm/Makefile
          sunxi-btlpm/sunxi-btlpm.c
